import lap 
import numpy as np
from scipy.optimize import linear_sum_assignment

def read_poscar(file_path):
    with open(file_path, 'r') as f:
        lines = f.readlines()
        lattice_vectors = np.array([list(map(float, lines[i].split())) for i in range(2, 5)])
        scale = float(lines[1])
        atom_types = lines[5].split()
        atom_numbers = list(map(int, lines[6].split()))
        total_atoms = sum(atom_numbers)
        positions = []
        selective_dynamics = []
        for line in lines[9:]:
            if line.strip() != '':
                data = line.split()
                positions.append(list(map(float, data[:3])))
                if len(data) > 3:
                    selective_dynamics.append(list(map(str, data[3:6])))
                else:
                    selective_dynamics.append(["T", "T", "T"])
        return scale, lattice_vectors, atom_types, atom_numbers, np.array(positions), selective_dynamics

# Function to write data to a POSCAR file
def write_poscar(file_path, scale, lattice_vectors, atom_types, atom_numbers, positions, selective_dynamics):
    with open(file_path, 'w') as f:
        f.write("Generated by script\n")
        f.write(f"{scale}\n")
        for vector in lattice_vectors:
            f.write(" ".join(["%12.8f" % i for i in vector]) + "\n")
        f.write(" ".join(atom_types) + "\n")
        f.write(" ".join([str(i) for i in atom_numbers]) + "\n")
        f.write("Selective dynamics\n")
        f.write("Direct\n")
        for pos, sd in zip(positions, selective_dynamics):
            f.write(" ".join(["%12.8f" % i for i in pos] + sd) + "\n")

# Read data from the initial and final POSCAR files
initial_poscar_path = 'POSCAR0'
final_poscar_path = 'POSCAR1'

# Minkowski distance function
def minkowski_distance(p1, p2, p=2):  # p=1 Manhattan, p=2 Euclidean
    return np.linalg.norm(p1 - p2, ord=p)

# Cosine distance function
def cosine_distance(p1, p2):
    return 1 - np.dot(p1, p2) / (np.linalg.norm(p1) * np.linalg.norm(p2))

# Chebyshev distance function
def chebyshev_distance(p1, p2):
    return np.max(np.abs(p1 - p2))

# Hamming distance function
def hamming_distance(s1, s2):
    return sum(c1 != c2 for c1, c2 in zip(s1, s2))

initial_scale, initial_lattice_vectors, initial_atom_types, initial_atom_numbers, initial_positions, initial_selective_dynamics = read_poscar(
    initial_poscar_path)
final_scale, final_lattice_vectors, final_atom_types, final_atom_numbers, final_positions, _ = read_poscar(
    final_poscar_path)  # Selective dynamics not needed for final positions
all_rearranged_positions = []
print(initial_atom_types, initial_atom_numbers, final_atom_types, final_atom_numbers)
# Create a dictionary to map the atom types to their indices in the initial and final POSCAR files
initial_atom_type_dict = {atom_type: i for i, atom_type in enumerate(initial_atom_types)}
final_atom_type_dict = {atom_type: i for i, atom_type in enumerate(final_atom_types)}

# Set initial values for row_ind and col_ind
row_ind_old, col_ind_old = None, None
cycle = 0
# Loop until row_ind and col_ind are the same
while True:
    cycle = cycle + 1
    initial_poscar_path = initial_poscar_path
    final_poscar_path = final_poscar_path
    initial_scale, initial_lattice_vectors, initial_atom_types, initial_atom_numbers, initial_positions, initial_selective_dynamics = read_poscar(
        initial_poscar_path)
    #     final_scale, final_lattice_vectors, final_atom_types, final_atom_numbers, final_positions, _ = read_poscar(final_poscar_path)
    for atom_type in initial_atom_types:
        
        # print (atom_type,initial_indices, final_indices)
        # Get the indices of the atoms of that type in the initial and final POSCAR files
        initial_indices = np.arange(sum(initial_atom_numbers[:initial_atom_type_dict[atom_type]]),
                                    sum(initial_atom_numbers[:initial_atom_type_dict[atom_type] + 1]))
        
        final_indices = np.arange(sum(final_atom_numbers[:final_atom_type_dict[atom_type]]),
                                  sum(final_atom_numbers[:final_atom_type_dict[atom_type] + 1]))
        # Compute the distances between initial and final positions for that type only using the Manhattan distance
        distances = np.zeros((len(initial_indices), len(final_indices)))
        for i, initial_index in enumerate(initial_indices):
            for j, final_index in enumerate(final_indices):
                distances[i, j] = (1.2*cosine_distance(initial_positions[initial_index], final_positions[final_index])+0.8*minkowski_distance(initial_positions[initial_index], final_positions[final_index]))/2
        
        
        
        distances=np.array(distances)
        # Use the Jonker Volgenant algorithm to find the optimal mapping for that type only
        #row_ind, col_ind = linear_sum_assignment(distances)
        result = lap.lapjv(distances)
        row_ind, col_ind = result[1], result[2]
#         print ('ro',row_ind_old,'ri', row_ind,'co',col_ind_old,'ci', col_ind)
#         print (row_ind,col_ind, atom_type)
        row_ind_old, col_ind_old = row_ind, col_ind
    
        #print(atom_type, row_ind, col_ind)
        for i, col in zip(initial_indices, final_indices[col_ind]):
            # print(col)
            all_rearranged_positions.append(initial_positions[col])

        if np.array_equal(row_ind_old, row_ind) and np.array_equal(col_ind_old, col_ind):
            # print(row_ind_old,row_ind, col_ind_old,  col_ind)
            print(f"Optimal mappings found. Exiting the loop for '{atom_type}' atom.")
            continue
        
        
    if cycle == 50:
        print('Infinite cycle: Interrupting at cycle ', cycle)
        break
#print(final_atom_types, final_atom_numbers)
new_poscar_path = 'new_POSCAR_combined'
write_poscar(new_poscar_path, final_scale, final_lattice_vectors, final_atom_types, final_atom_numbers,
             np.array(all_rearranged_positions), initial_selective_dynamics)
# Print a message after the loop is done
print("Rearrangement for all atom types completed.")
